<!DOCTYPE html>
<html>
    <head>
        <title>Webcraft</title>
    </head>
    <body>
        <canvas width="400" height="400"></canvas>
    </body>
    
    
    <script id="fragment" type="shader/fragment">
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float; 
        #else
            precision mediump float;
        #endif
        
        uniform float time;
        uniform vec2 scale;
        
        uniform vec3 player;
        uniform vec3 direct;
        
        
        #define FOCAL_LENGTH 1.0
        
        #define MARCH_STEPS 28
        #define MARCH_FADE  20.0
        
        #define AMBIENT_LIGHT vec3(0.32, 0.36, 0.4)
        #define DIFFUSE_LIGHT vec3(0.5, 0.45, 0.15)
        
        #define GRASS vec3(0.25, 1.0, 0.0)
        #define DIRT  vec3(1.0, 0.6, 0.1)
        #define STONE vec3(0.7, 0.7, 0.7)
        
        
        
        #define slowrand(n) fract(sin(mod(dot(n, vec3(1.42887,8.6025,13.1525)), 3.14159))*627.7327)
        #define fastrand(n) fract(dot(n, vec3(131.43,14.11,86.56)))
        
        
        //float hash( in float n ) { return fract(sin(n)*753.5453123); }
        //float hash( in float n ) { return fract(fract(n)*753.5453123); }
        #define hash(n) fract(sin(mod(n, 3.14159))*627.7327)
        float noise( in vec3 x )
        {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);
        	
            float n = p.x + p.y*157.0 + 113.0*p.z;
            return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                           mix( hash(n+157.0), hash(n+158.0),f.x),f.y),
                       mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                           mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
        }
        
        float terrain(in vec3 p){
            p *= 0.2;
            float x = noise(p) + 0.4 + hash(p.x + p.y*157.0 + 113.0*p.z) * 0.1;
            return 1.0 - x*x;
        }
        
        vec3 march(in vec3 ro, in vec3 rd){
            vec3 dt = abs(1.0 / rd);
            vec3 p = floor(ro);
            vec3 n = max(vec3(0.00001), 1.0 / rd) - (ro - p) / rd;
            vec3 inc = sign(rd);
            
            float t = 0.0;
            
            vec3 surf;
            
            for (int i = 0; i < MARCH_STEPS; i++){
                surf = vec3(0);
                if(n.x < n.y) {
                    if(n.x < n.z) {
                        p.x += inc.x;
                        t = n.x;
                        n.x += dt.x;
                        surf.x = inc.x;
                    } else {
                        p.z += inc.z;
                        t = n.z;
                        n.z += dt.z;
                        surf.z = inc.z;
                    }
                } else {
                    if(n.y < n.z) {
                        p.y += inc.y;
                        t = n.y;
                        n.y += dt.y;
                        surf.y = inc.y;
                    } else {
                        p.z += inc.z;
                        t = n.z;
                        n.z += dt.z;
                        surf.z = inc.z;
                    }
                }
                
                if (terrain(p) < 0.0) break;
            }
            
            ro += rd * t;
            
            vec3 col;
            if (terrain(p-vec3(0,1,0)) >= 0.0 && 
                (surf.y > 0.5 || fract(ro-0.0001).y < 0.25)){
                col = GRASS;
            } else {
                if (p.y < 2.0 - fastrand(p)*3.0){ 
                    col = DIRT;
                } else {
                    col = STONE;
                }
            }
            
            float mul = slowrand(floor(ro*12.0+0.001));
            
            col *= mul * 0.3 + 0.7;
            
            vec3 phong = AMBIENT_LIGHT;
            phong += max(0.2, dot(rd, surf)) * DIFFUSE_LIGHT;
            
            vec3 bright = phong * (1.0 - t / MARCH_FADE);
            
            return col * bright;
        }
        
        void main()
        {
        	vec2 uv = 1.0 - gl_FragCoord.xy / 200.0;
        	
            vec3 ro = player;
            vec3 rd = normalize(vec3(uv, FOCAL_LENGTH));
            
            float t = rd.z;
            rd.z = rd.z * direct.z - rd.x * direct.x;
            rd.x = t    * direct.x + rd.x * direct.z;
            
            gl_FragColor = vec4(march(ro, rd), 1.0);
        }
    </script>
    
    <script type="text/javascript" src="vector.js"></script>
    <script type="text/javascript" src="pixelshader.js"></script>
    <script type="text/javascript" src="input.js"></script>
    <script type="text/javascript" src="player.js"></script>
    <script type="text/javascript" src="app.js"></script>
    <script type="text/javascript" src="collision.js"></script>
</html>